<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>桥梁健康监测系统</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* Nicer font */
            background-color: #333366; /* Match scene background */
        }
        canvas { 
            display: block; 
        }
        #status {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(0,0,0,0.75);
            color: #eee;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 13px;
            transition: opacity 0.5s ease-out;
            z-index: 100; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .data-tag {
            position: absolute;
            background: linear-gradient(145deg, rgba(40, 40, 70, 0.85), rgba(60, 60, 90, 0.9)); /* Gradient background */
            color: #f0f0f0;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
            pointer-events: auto;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1); /* Smoother transition */
            border: 1px solid rgba(255, 255, 255, 0.2); /* Subtle border */
            border-left-width: 5px; /* Status color indicator on the left */
            transform: translate(-50%, -50%);
            z-index: 10;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4); /* Deeper shadow */
            min-width: 150px; /* Ensure minimum width */
            text-align: left;
        }
        .data-tag .title {
            font-weight: 600; /* Slightly bolder */
            font-size: 13px; /* Smaller title */
            margin-bottom: 5px;
            color: #aaa; /* Dim title slightly */
            display: block;
        }
        .data-tag .value {
            font-weight: 700; /* Bolder value */
            font-size: 18px; /* Larger value */
            margin-bottom: 3px;
            display: block;
            letter-spacing: 0.5px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5); /* Text shadow for pop */
        }
        .data-tag .description {
            display: none;
            font-size: 12px;
            line-height: 1.4;
            margin-top: 8px;
            max-width: 200px;
            color: #ccc;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 8px;
        }
        .data-tag:hover {
            background: linear-gradient(145deg, rgba(50, 50, 80, 0.9), rgba(70, 70, 100, 0.95));
            transform: translate(-50%, -50%) scale(1.08); /* Slightly larger hover scale */
            z-index: 1000;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.5);
        }
        .data-tag:hover .description {
            display: block;
        }
         /* Define status colors */
        .data-tag.status-normal {
            border-left-color: #00f2a1; /* Brighter Green */
        }
        .data-tag.status-warning {
             border-left-color: #ffc107; /* Amber/Orange */
        }
        .data-tag.status-danger {
             border-left-color: #f44336; /* Material Red */
        }
         .data-tag.status-normal .value {
             color: #00f2a1;
         }
        .data-tag.status-warning .value {
            color: #ffc107;
        }
        .data-tag.status-danger .value {
            color: #f44336;
        }
    </style>
</head>
<body>
    <div id="status">加载桥梁模型中...</div>

    <!-- 这里使用CDN加载Three.js和相关库 -->
    <script src="three_js/three.min.js"></script>
    <script src="three_js/OrbitControls.js"></script>
    <script src="three_js/GLTFLoader.js"></script>

    <script>
        // 初始化Three.js
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x333366);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 2, 0);
        controls.update();
        
        // 添加适当的灯光
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 7.5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight2.position.set(-5, 8, -7);
        scene.add(directionalLight2);
        
        // 全局变量
        let bridge;
        let dataLabels = [];
        let autoUpdateInterval;
        let screenPositions = {};
        
        // Define status colors directly for JS usage if needed, 
        // but primarily rely on CSS classes now
        const statusColors = {
            normal: '#00f2a1',
            warning: '#ffc107',
            danger: '#f44336'
        };

        // 监测数据状态对象 (Add properties for cached dimensions)
        const monitoringData = [
            {
                name: "结构应力",
                value: "120 MPa",
                description: "当前该部位所承受的应力值，低于设计允许的最大应力值 150MPa，处于正常范围。", 
                position: null, 
                normalRange: [100, 140],
                warningRange: [140, 150],
                dangerThreshold: 150,
                currentValue: 120,
                unit: "MPa",
                labelWidth: null, // Cached width
                labelHeight: null // Cached height
            },
            {
                name: "位移",
                value: "竖向: 5mm, 水平: 2mm",
                description: "跨中竖向位移在允许范围内，表明梁体变形正常；桥墩顶部水平位移较小，说明桥墩稳定性良好。",
                position: null,
                verticalValue: 5,
                horizontalValue: 2,
                verticalNormalRange: [0, 8],
                horizontalNormalRange: [0, 5],
                verticalUnit: "mm",
                horizontalUnit: "mm",
                labelWidth: null,
                labelHeight: null
            },
            {
                name: "振动频率",
                value: "10.5 Hz",
                description: "与桥梁初始设计频率 10Hz 相比，略有变化但在合理波动范围内，结构未出现明显损伤迹象。",
                position: null,
                normalRange: [9.5, 10.5],
                warningRange: [9.0, 11.0],
                currentValue: 10.5,
                unit: "Hz",
                labelWidth: null,
                labelHeight: null
            },
            {
                name: "索力",
                value: "800 kN",
                description: "该斜拉索的拉力值，与设计索力 750kN 相比，偏差在允许范围内，索力分布较为均匀。",
                position: null,
                normalRange: [700, 850],
                warningRange: [650, 900],
                currentValue: 800,
                unit: "kN",
                labelWidth: null,
                labelHeight: null
            }
        ];

        // 加载模型
        const loader = new THREE.GLTFLoader();
        const statusElement = document.getElementById('status');
        
        loader.load(
            'bridge-minified.glb',  // 模型路径
            function(gltf) {
                bridge = gltf.scene;
                scene.add(bridge);
                
                
                // Adjust camera for better initial view
                fitCameraToObject(bridge);
                
                // Set label anchor points closer to center
                setMonitoringPositions(bridge);
                
                // Create 3D positioned labels
                createDataLabels();
                
                // Initial data display
                updateAllData(false);
                
                statusElement.textContent = "模型加载完成，数据已初始化";
                
                setTimeout(() => {
                    statusElement.style.opacity = '0';
                    setTimeout(() => statusElement.style.display = 'none', 500);
                }, 3000);

                // Start auto-update by default
                startAutoUpdate(); 

            },
            // 进度回调
            function(xhr) {
                statusElement.textContent = `加载模型: ${Math.floor((xhr.loaded / xhr.total) * 100)}%`;
            },
            // 错误回调
            function(error) {
                console.error('模型加载错误:', error);
                statusElement.textContent = "模型加载错误! 显示备用模型...";
                
                createFallbackBridge();
                // Start auto-update for fallback too
                startAutoUpdate(); 
            }
        );
        
        // Revert to the original close-up camera view
        function fitCameraToObject(obj) {
            const box = new THREE.Box3().setFromObject(obj);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraDistance = maxDim / (2 * Math.tan(fov / 2));
            
            // --- Revert to original aggressive zoom ---
            cameraDistance /= 12; 

            const minDistance = 1; // Revert to original min distance
            cameraDistance = Math.max(minDistance, cameraDistance);
            
            // Revert to original offset calculation for the close view
            const offset = new THREE.Vector3(1, 0.5, 1).normalize().multiplyScalar(cameraDistance);
            camera.position.copy(center).add(offset);

            controls.target.copy(center);
            controls.update();
        }
        
        // Set anchor points moderately spread around the center (as a base for 2D avoidance)
        function setMonitoringPositions(model) {
            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            // Use moderate offsets 
            const offsetX = 19.0; 
            const offsetY = 15.5;  
            const offsetZ = 3.0;  
            
            const baseHeight = center.y + 1.0;

            monitoringData[0].position = new THREE.Vector3(
                center.x - offsetX,
                baseHeight+ offsetY, 
                center.z + offsetZ
            ); // Front-Top-Right
            monitoringData[1].position = new THREE.Vector3(
                center.x + offsetX*1.5, 
                baseHeight -offsetY, 
                center.z - offsetZ
            ); // Back-Top-Left
            monitoringData[2].position = new THREE.Vector3(
                center.x - offsetX, 
                baseHeight + offsetY*0.8, 
                center.z - offsetZ
            ); // Back-Bottom-Right
            monitoringData[3].position = new THREE.Vector3(
                
                center.x + offsetX, 
                baseHeight + offsetY, 
                center.z + offsetZ
            ); // Front-Bottom-Left
        }

        // Create 3D positioned HTML labels and cache dimensions
        function createDataLabels() {
            dataLabels.forEach(label => {
                if (label.parentNode) document.body.removeChild(label);
            });
            dataLabels = [];
            
            monitoringData.forEach((data, index) => {
                const labelDiv = document.createElement('div');
                labelDiv.className = 'data-tag';
                labelDiv.id = `data-tag-${index}`;
                
                const titleElement = document.createElement('div');
                titleElement.className = 'title';
                titleElement.textContent = data.name;
                labelDiv.appendChild(titleElement);
                
                const valueElement = document.createElement('div');
                valueElement.className = 'value';
                valueElement.textContent = data.value;
                labelDiv.appendChild(valueElement);
                
                const descriptionElement = document.createElement('div');
                descriptionElement.className = 'description';
                descriptionElement.textContent = data.description;
                labelDiv.appendChild(descriptionElement);
                
                document.body.appendChild(labelDiv);
                
                data.labelElement = labelDiv;
                data.valueElement = valueElement;
                data.descriptionElement = descriptionElement;
                dataLabels.push(labelDiv);

                // --- Cache dimensions after creation --- 
                // Temporarily make it visible but off-screen to measure
                labelDiv.style.position = 'absolute'; // Ensure it's positioned
                labelDiv.style.visibility = 'hidden';
                labelDiv.style.display = 'block';
                data.labelWidth = labelDiv.offsetWidth;
                data.labelHeight = labelDiv.offsetHeight;
                labelDiv.style.display = 'none'; // Hide again immediately
                labelDiv.style.visibility = 'visible';
                // Reset position if needed, although it's set each frame in update
                // ----------------------------------------
            });
             updateLabelPositions(); // Initial position update using cached dimensions
        }
        
        // Update label screen positions using cached dimensions
        function updateLabelPositions() {
            const placedLabelRects = []; 
            const labelVerticalPadding = 5; 
            const globalYShift = -30; 

            const initialProjections = monitoringData.map(data => {
                if (!data.position) return null;
                const position = data.position.clone();
                position.project(camera);
                if (position.z > 1) return null; 
                return {
                    x: (position.x * 0.5 + 0.5) * window.innerWidth,
                    y: (-position.y * 0.5 + 0.5) * window.innerHeight
                };
            });

            let avgYBottom = null;
            const bottomPairIndices = [0, 1]; 
            const bottomYs = bottomPairIndices
                .map(i => initialProjections[i]?.y)
                .filter(y => y !== undefined && y !== null);
            if (bottomYs.length > 0) {
                 avgYBottom = bottomYs.reduce((sum, y) => sum + y, 0) / bottomYs.length;
            }
           
            let avgYTop = null;
            const topPairIndices = [2, 3]; 
            const topYs = topPairIndices
                .map(i => initialProjections[i]?.y)
                .filter(y => y !== undefined && y !== null);
            if (topYs.length > 0) {
                avgYTop = topYs.reduce((sum, y) => sum + y, 0) / topYs.length;
            }

            monitoringData.forEach((data, index) => {
                const labelElement = data.labelElement;
                const initialProj = initialProjections[index];
                const labelWidth = data.labelWidth;   // Use cached width
                const labelHeight = data.labelHeight; // Use cached height

                if (!initialProj || !labelElement || !labelWidth || !labelHeight) { // Check cache too
                    if (labelElement) labelElement.style.display = 'none';
                    return;
                }

                let targetX = initialProj.x;
                let targetY = initialProj.y; 

                if (bottomPairIndices.includes(index) && avgYBottom !== null) {
                    targetY = avgYBottom; 
                } else if (topPairIndices.includes(index) && avgYTop !== null) {
                    targetY = avgYTop; 
                }
                
                targetY += globalYShift;

                // --- No need to calculate dimensions here anymore --- 
                
                // Calculate initial bounding box using cached dimensions and target pos
                let currentLeft = targetX - labelWidth / 2;
                let currentTop = targetY - labelHeight / 2;
                let currentRight = currentLeft + labelWidth;
                let currentBottom = currentTop + labelHeight;

                // --- Collision Detection and Avoidance (uses cached height) --- 
                let collisionDetected = true;
                let attempts = 0;
                const maxAttempts = 15; 

                while (collisionDetected && attempts < maxAttempts) {
                    collisionDetected = false;
                    for (const placedRect of placedLabelRects) {
                        const overlaps = 
                            currentLeft < placedRect.right &&
                            currentRight > placedRect.left &&
                            currentTop < placedRect.bottom &&
                            currentBottom > placedRect.top;

                        if (overlaps) {
                            collisionDetected = true;
                            currentTop = placedRect.bottom + labelVerticalPadding;
                            currentBottom = currentTop + labelHeight; // Use cached height
                            targetY = currentTop + labelHeight / 2;   // Use cached height
                            currentLeft = targetX - labelWidth / 2;  // Use cached width
                            currentRight = currentLeft + labelWidth; // Use cached width
                            break; 
                        }
                    }
                    attempts++;
                }

              

                // --- Final Placement (check bounds using cached dimensions) --- 
                const finalTop = targetY - labelHeight / 2;    // Use cached height
                const finalBottom = finalTop + labelHeight;  // Use cached height
                const finalLeft = targetX - labelWidth / 2;   // Use cached width
                const finalRight = finalLeft + labelWidth; // Use cached width
                
                if (finalLeft < 0 || finalRight > window.innerWidth || finalTop < 0 || finalBottom > window.innerHeight) {
                    labelElement.style.display = 'none';
                } else {
                    labelElement.style.left = targetX + 'px'; 
                    labelElement.style.top = targetY + 'px';  
                    labelElement.style.display = 'block';

                    placedLabelRects.push({
                        left: finalLeft, 
                        top: finalTop,   
                        right: finalRight,
                        bottom: finalBottom 
                    });
                }
            });
        }
        
        // Randomly update all data
        function updateAllData(isRandom = true) {
            if (isRandom) {
                updateStressData(110 + Math.random() * 45); 
                updateDisplacementData(3 + Math.random() * 7, 1 + Math.random() * 5); 
                updateFrequencyData(9 + Math.random() * 2.5); 
                updateTensionData(650 + Math.random() * 300); 
            } else {
                updateStressData(monitoringData[0].currentValue);
                updateDisplacementData(monitoringData[1].verticalValue, monitoringData[1].horizontalValue);
                updateFrequencyData(monitoringData[2].currentValue);
                updateTensionData(monitoringData[3].currentValue);
            }
        }
        
        // Helper function to set status class
        function setStatusClass(element, status) {
            element.classList.remove('status-normal', 'status-warning', 'status-danger');
            element.classList.add(`status-${status}`);
        }

        // Update functions now set CSS class for color styling
        function updateStressData(value) {
            const data = monitoringData[0];
            data.currentValue = Number(value.toFixed(1));
            data.value = `${data.currentValue} ${data.unit}`;
            
            let status = 'normal';
            if (data.currentValue > data.dangerThreshold) {
                status = 'danger';
                data.description = `当前该部位所承受的应力值超过设计允许的最大应力值 ${data.dangerThreshold}MPa，处于危险范围!`;
            } else if (data.currentValue >= data.warningRange[0]) { 
                status = 'warning';
                data.description = `当前该部位所承受的应力值接近设计允许的最大应力值 ${data.dangerThreshold}MPa，需注意监测!`;
            } else {
                status = 'normal';
                data.description = `当前该部位所承受的应力值，低于设计允许的最大应力值 ${data.dangerThreshold}MPa，处于正常范围。`;
            }
            
            if (data.labelElement) {
                data.valueElement.textContent = data.value;
                setStatusClass(data.labelElement, status); // Set class
                data.descriptionElement.textContent = data.description;
            }
        }
        
        function updateDisplacementData(verticalValue, horizontalValue) {
            const data = monitoringData[1];
            data.verticalValue = Number(verticalValue.toFixed(1));
            data.horizontalValue = Number(horizontalValue.toFixed(1));
            data.value = `竖向: ${data.verticalValue}${data.verticalUnit}, 水平: ${data.horizontalValue}${data.horizontalUnit}`;
            
            let status = 'normal';
            if (data.verticalValue > data.verticalNormalRange[1] || data.horizontalValue > data.horizontalNormalRange[1]) {
                status = 'warning';
                data.description = `位移值接近极限范围，需要密切监测桥梁结构变形情况。`;
            } else {
                status = 'normal';
                data.description = `跨中竖向位移在允许范围内，表明梁体变形正常；桥墩顶部水平位移较小，说明桥墩稳定性良好。`;
            }
            
            if (data.labelElement) {
                data.valueElement.textContent = data.value;
                setStatusClass(data.labelElement, status); // Set class
                data.descriptionElement.textContent = data.description;
            }
        }
        
        function updateFrequencyData(value) {
            const data = monitoringData[2];
            data.currentValue = Number(value.toFixed(1));
            data.value = `${data.currentValue} ${data.unit}`;
            
            let status = 'normal';
            if (data.currentValue < data.normalRange[0] || data.currentValue > data.normalRange[1]) {
                if (data.currentValue < data.warningRange[0] || data.currentValue > data.warningRange[1]) {
                    status = 'danger';
                    data.description = `振动频率异常，可能表明结构出现严重损伤，需立即检查!`;
                } else {
                    status = 'warning';
                    data.description = `振动频率出现波动，需监测结构是否出现细微损伤。`;
                }
            } else {
                status = 'normal';
                data.description = `与桥梁初始设计频率 10Hz 相比，略有变化但在合理波动范围内，结构未出现明显损伤迹象。`;
            }
            
            if (data.labelElement) {
                data.valueElement.textContent = data.value;
                setStatusClass(data.labelElement, status); // Set class
                data.descriptionElement.textContent = data.description;
            }
        }
        
        function updateTensionData(value) {
            const data = monitoringData[3];
            data.currentValue = Math.floor(value);
            data.value = `${data.currentValue} ${data.unit}`;
            
            let status = 'normal';
            if (data.currentValue < data.normalRange[0] || data.currentValue > data.normalRange[1]) {
                if (data.currentValue < data.warningRange[0] || data.currentValue > data.warningRange[1]) {
                    status = 'danger';
                    data.description = `索力严重偏离设计值，可能造成桥梁结构不稳定，需立即检查!`;
                } else {
                    status = 'warning';
                    data.description = `索力偏离设计值 750kN，但仍在允许波动范围内，需密切监测。`;
                }
            } else {
                status = 'normal';
                data.description = `该斜拉索的拉力值，与设计索力 750kN 相比，偏差在允许范围内，索力分布较为均匀。`;
            }
            
            if (data.labelElement) {
                data.valueElement.textContent = data.value;
                setStatusClass(data.labelElement, status); // Set class
                data.descriptionElement.textContent = data.description;
            }
        }
        
        // Function to start auto update (default behavior)
        function startAutoUpdate() {
            if (autoUpdateInterval) {
                clearInterval(autoUpdateInterval);
            }
                autoUpdateInterval = setInterval(() => {
                updateAllData(true);
            }, 5000); // Update every 5 seconds
            updateAllData(true); // Initial random update right away
            }
        
        // Handle window resize
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateLabelPositions(); 
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            updateLabelPositions(); // Update label positions each frame
            renderer.render(scene, camera);
        }
        
        animate();

    </script>
</body>
</html>