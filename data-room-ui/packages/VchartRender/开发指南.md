# VchartRender 开发指南 (V5 - 终版：框架骨架与 VChart 血肉)

**核心目标:** 清晰分离**通用框架 (骨架)** 与 **VChart 适配层 (血肉)**，指导开发者在遵循框架的前提下，高效完成 VChart 的接入。

**核心原则:**

1.  **拥抱框架:** 不要试图改变 Mixins (`commonMixins`, `linkageMixins`) 定义的核心流程和 Vuex 交互模式。
2.  **聚焦适配:** `VchartRender` 的核心工作是**实现 VChart 的适配逻辑**，将其精确地填充到框架预留的接口中。
3.  **职责清晰:** 严格遵守各覆盖方法和辅助函数的职责划分。

---

## 第一部分：通用框架 (骨架 - 必须遵循)

这部分定义了所有渲染组件（如 EchartsRender, PlotRender, VchartRender）都必须遵守的基础结构和核心流程。

### 1. 基础结构与依赖

*   **Vue 模板:** 复用现有结构，包含一个用于挂载图表的 `div`，其 `id` 通过 `chatId` 计算属性生成。
*   **Props:** 继承标准 `config` prop，并将 `isPreview` 重命名为 `previewMode` 以避免 Mixin 冲突。
*   **Mixins:**
    *   `commonMixins`: 提供数据获取 (`changeDataByCode`, `changeData`)、基础样式处理 (`changeStyle` 默认实现)、初始化 (`chartInit` 默认实现)、Vuex 同步相关的基础逻辑。
    *   `linkageMixins`: 提供数据联动 (`linkage`, `dataInit` 默认实现) 相关逻辑。
*   **Vuex:** 使用 `mapState` 映射必要的状态 (如 `customTheme`, `activeCode`)，使用 `mapMutations` 映射 `changeChartConfig` 和 `changeActiveItemConfig`。
*   **生命周期与 Watchers:** 通常由 Mixins 处理，组件内一般无需额外定义 `mounted`, `beforeDestroy`, `watch` (除非有 VChart 特殊需求)。
*   **Data:** 包含 `chart` 实例变量 (初始为 `null`)。

### 2. 核心流程 (框架视角 - 5 个核心步骤)

框架通过 Mixins 和需要组件覆盖的方法，定义了以下标准流程：

1.  **初始化 Config (`chartInit` 覆盖点):**
    *   **触发:** 组件挂载后，由 `commonMixins` 的 `mounted` 钩子调用组件的 `chartInit` 方法。
    *   **框架职责:** `commonMixins` 提供了 `chartInit` 的基础实现，包含判断是否首次加载 (`isPreview` 或 `config.key === config.code`)、调用 `changeStyle` 应用初始样式、调用 `changeDataByCode` 触发数据获取、处理 Loading 状态、并在 `.then` 中调用 `newChart`。
    *   **组件覆盖职责:** 覆盖 `chartInit` 以**编排**加载流程，确保按顺序调用 `this.changeStyle` (应用初始自定义设置) -> `this.changeDataByCode` (启动数据流) -> `.then(this.newChart)` (渲染)。

2.  **同步配置变更 (`changeStyle` 覆盖点):**
    *   **触发:** 用户在配置面板的 "Custom" Tab 修改设置时，或主题切换时。
    *   **框架职责:** `commonMixins` 提供了 `changeStyle` 的基础实现 (应用主题)。
    *   **组件覆盖职责:** 覆盖 `changeStyle` 以处理**样式和自定义选项**的变更。主要负责：
        *   调用**特定图表库的样式应用逻辑** (例如，调用 `applyStylesAndHandlers` 来应用 VChart 的 `custom` 设置和 `optionHandler`)。
        *   调用 `updateVuexWithConfig` 将变更同步到 Vuex。
        *   **不负责渲染**。

3.  **关联数据 (`dataFormatting` 覆盖点):**
    *   **触发:** 由 `commonMixins` 的 `changeDataByCode` 或 `changeData` 在成功从 API 获取数据后**自动调用**。
    *   **框架职责:** Mixin 负责发起 API 请求，获取原始数据，并将数据和当前 `config` 传递给组件的 `dataFormatting` 方法。
    *   **组件覆盖职责:** 覆盖 `dataFormatting` 以**处理和适配数据**。主要负责：
        *   执行通用的 `dataHandler` 脚本。
        *   将 API 数据**转换为特定图表库能理解的数据结构** (例如，调用 `mapDataToVChartSpec` 将数据放入 VChart Spec 的 `data` 字段)。
        *   应用来自配置面板 "Data" Tab 的**数据相关设置** (例如，调用 `applySettingsToVChartSpec(config, 'data')` 应用 VChart 的 `xField`, `yField` 等)。
        *   返回**处理完毕**的 `config` 对象给 Mixin 的 Promise。

4.  **生成图表库 Option/Spec:**
    *   这不是一个单独的方法，而是由多个环节共同完成：
        *   **基础 Spec:** 来自图表配置文件的 `defaultOption`。
        *   **数据部分:** 由 `dataFormatting` 处理和填充 (`data`, `xField`, `yField` 等)。
        *   **样式/自定义部分:** 由 `changeStyle` (及其调用的辅助函数) 处理和修改。
    *   **最终结果:** `config.option` 包含了驱动图表渲染所需的所有信息。

5.  **渲染图表 (`newChart` 覆盖点):**
    *   **触发:** 在 `chartInit` 或 `dataInit` (联动) 的数据获取流程 `.then` 中被调用。
    *   **框架职责:** 无，完全由组件实现。
    *   **组件覆盖职责:** 覆盖 `newChart` 以**执行渲染**。主要负责：
        *   接收包含最终 `option/spec` 的 `config` 对象。
        *   **销毁**旧的图表实例。
        *   使用 `config.option` **创建和渲染**新的图表实例。
        *   **注册**必要的图表事件 (用于联动等)。

### 3. Mixin 与 Vuex 交互

*   `commonMixins`: 驱动数据加载 (`changeDataByCode`, `changeData`) 和初始化流程 (`chartInit`)，并在数据获取后调用 `dataFormatting`。
*   `linkageMixins`: 监听联动事件，调用 `dataInit` (通常覆盖后会调用 `changeData` 重新获取数据并用 `newChart` 渲染)。
*   `changeChartConfig` (Mutation): 用于将组件配置的**非渲染关键变更** (如样式、布局、设置等，但不一定是数据本身) 同步到 Vuex Store 中。
*   `changeActiveItemConfig` (Mutation): 当活动组件的配置变更时，同步到 Vuex 中专门存储活动组件配置的状态。

---

## 第二部分：VChart 适配层 (血肉 - 需要实现)

这部分描述了 `VchartRender` 需要具体编写的代码，以将 VChart 库接入通用框架。

### 1. 核心覆盖方法的具体实现

*   **`chartInit()`:**
    ```javascript
    chartInit () {
      let config = this.config;
      const isInitialLoad = this.isPreview || config.key === config.code; // 或其他判断首次加载的逻辑
      if (isInitialLoad) {
        // 1. 应用初始样式并同步 Vuex (不渲染)
        config = this.changeStyle(config); 
        // 2. 启动 Mixin 数据获取流程 (异步)
        this.changeDataByCode(config)
          .then((finalConfig) => {
            // 3. Mixin 调用 dataFormatting 处理完数据后，用最终配置渲染
            this.newChart(finalConfig);
          })
          .catch(error => {
            console.error("[VchartRender chartInit] Error during initial data fetch or render:", error);
            // 处理错误，例如显示错误信息
          });
      } else {
        // 处理非首次加载的逻辑，通常由 watch 或 linkageMixins 触发 dataInit
        // 如果需要，可以添加这里的逻辑，但通常框架已处理
      }
    }
    ```
*   **`changeStyle(config, isUpdateTheme)`:**
    ```javascript
    changeStyle (config, isUpdateTheme) {
      config = { ...this.config, ...config }; // 合并传入的配置
      // 1. 应用 VChart 的样式、自定义设置和 optionHandler
      config = this.applyStylesAndHandlers(config);
      // 2. 同步 Vuex (如果不是主题更新触发)
      if (!isUpdateTheme) {
         // config.theme = settingToTheme(...) // 如果 VChart 需要主题转换
         this.updateVuexWithConfig(config);
      }
      // 3. 如果图表已存在，并且希望样式实时更新 (可选，取决于性能和需求)
      // if (this.chart) {
      //   this.chart.updateSpec(config.option); // 使用 VChart 的 API 更新 Spec
      // }
      return config; // 返回更新后的 config
    }
    ```
*   **`dataFormatting(config, apiData)`:**
    ```javascript
    dataFormatting (config, apiData) {
      if (apiData.success) {
        // --- 核心适配步骤 --- 
        // 1. 执行通用 dataHandler (如果存在)
        config = this.executeDataHandler(config, apiData.data);
        // 2. 将处理后的数据映射到 VChart Spec
        config = this.mapDataToVChartSpec(config, config.runtimeData || apiData.data); // 使用 dataHandler 可能产生的新数据源
        // 3. 应用 Data Tab 的设置到 VChart Spec
        config = this.applySettingsToVChartSpec(config, 'data');
        // --- 适配结束 --- 
      } else {
        console.error(`[VchartRender dataFormatting] API data fetch failed for ${config.code}:`, apiData);
        // 处理数据获取失败情况，例如使用默认数据或清空图表
        config.option.data = []; // 清空数据示例
      }
      // 清理临时运行时数据 (如果 executeDataHandler 使用了它)
      delete config.runtimeData; 
      return config; // 返回最终处理好的 config
    }
    ```
*   **`newChart(config)`:**
    ```javascript
    newChart (config) {
      if (!config || !config.option) {
        console.error('[VchartRender newChart] Invalid config provided.');
        return;
      }
      // 1. 获取容器
      const chartContainer = document.getElementById(this.chatId);
      if (!chartContainer) {
         console.error(`[VchartRender newChart] Container element #${this.chatId} not found.`);
         return;
      }
      // 2. 销毁旧实例
      if (this.chart) {
        try {
          this.chart.release(); // 使用 VChart 的销毁 API
        } catch (e) {
           console.error('[VchartRender newChart] Error releasing previous VChart instance:', e);
        }
        this.chart = null;
      }
      // 3. 创建新实例并渲染
      try {
        this.chart = new VChart(config.option, { dom: chartContainer }); // 使用 VChart API 创建
        this.chart.renderAsync(); // 使用 VChart API 渲染
        // 4. 注册事件
        this.registerEvent();
      } catch (e) {
        console.error('[VchartRender newChart] Error creating or rendering VChart instance:', e);
        console.error('[VchartRender newChart] VChart Spec causing error:', JSON.stringify(config.option));
        // 可以在此显示错误提示
      }
    }
    ```
*   **`dataInit(filterList)`:** (由 `linkageMixins` 触发)
    ```javascript
    dataInit (filterList) {
      // 1. 调用 Mixin 的 changeData 获取联动数据
      this.changeData(this.config, filterList)
        .then(finalConfig => {
          // 2. 使用联动后的数据重新渲染
          this.newChart(finalConfig);
        })
        .catch(error => {
          console.error('[VchartRender dataInit] Error during linked data fetch or render:', error);
        });
    }
    ```

### 2. VChart 特定辅助函数

这些函数封装了 VChart 的具体适配逻辑，被上述核心方法调用。

*   **`applySettingsToVChartSpec(config, settingType)`:**
    *   **核心职责:** 将 `config.setting` 中的配置项根据 `optionField` 映射到 `config.option` (VChart Spec) 的**正确路径**。
    *   **实现要点:** 使用 `lodash.set(config.option, setting.optionField, setting.value)`。需要仔细核对 VChart Spec 文档，确保 `optionField` 的路径字符串 (如 `'axes[0].title.text'`, `'markLine[0].label.formatter'`) 与 VChart Spec 结构完全匹配。区分处理 `settingType === 'custom'` 和 `settingType === 'data'` 的配置。
*   **`mapDataToVChartSpec(config, data)`:**
    *   **核心职责:** 将 `dataFormatting` 中处理后的数据 (`data`) 放入 `config.option` (VChart Spec) 中 VChart 需要的位置。
    *   **实现要点:** 通常是 `config.option.data = { id: 'sourceData', values: data };` 或类似形式，取决于 VChart Spec 对数据的要求 (可能是单个 data 对象，或 data 数组)。
*   **`executeDataHandler(config, rawData)`:**
    *   **核心职责:** 安全地执行 `config.dataHandler` 脚本。
    *   **实现要点:** 使用 `new Function('data', 'option', 'setting', script)` 执行。注意错误捕获。执行结果可能会修改 `option` 或返回新的数据，需要相应处理 (例如，将返回的新数据存入 `config.runtimeData` 供 `mapDataToVChartSpec` 使用)。
*   **`applyStylesAndHandlers(config)`:**
    *   **核心职责:** 组合应用样式设置 (`custom`) 和执行 `optionHandler`。
    *   **实现要点:**
        1.  调用 `applySettingsToVChartSpec(config, 'custom')`。
        2.  安全地执行 `config.optionHandler` (使用 `new Function('option', 'VChart', script)`)，允许用户脚本直接修改 `option` 或访问 VChart 对象。
*   **`registerEvent()`:**
    *   **核心职责:** 为图表实例注册 VChart 事件监听器，主要用于数据联动。
    *   **实现要点:** 使用 `this.chart.on('click', params => { ... });` 或其他 VChart 支持的事件。在回调中调用 `extractLinkageData(params)`。
*   **`extractLinkageData(eventParams)`:**
    *   **核心职责:** 从 VChart 事件对象 (`eventParams`) 中提取用于数据联动的字段和值。
    *   **实现要点:** 解析 `eventParams` 的结构 (例如 `eventParams.datum`)，找到触发事件的图形元素对应的数据项，提取所需的字段和值，然后调用 `this.linkage(extractedData)`。
*   **`updateVuexWithConfig(config)`:**
    *   **核心职责:** 将配置变更安全地同步到 Vuex。
    *   **实现要点:** 使用 `lodash.isEqual` 比较当前配置与上次同步到 Vuex 的配置，如果发生变化，则 `cloneDeep` 当前 `config` 并调用 `this.changeChartConfig(clonedConfig)` 和 `this.changeActiveItemConfig(clonedConfig)`。

### 3. 其他适配

*   **库导入:** `import VChart from '@visactor/vchart';`
*   **样式:** 可能需要引入 VChart 的 CSS 或自定义样式。

---

**总结:** 遵循此指南，开发者应将精力集中在**第二部分**的 VChart 适配逻辑实现上，而**第一部分**的框架流程则应严格遵守，确保 `VchartRender` 能无缝集成到现有系统中。
